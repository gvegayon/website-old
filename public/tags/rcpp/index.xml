<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rcpp on GGVY</title>
    <link>/tags/rcpp/</link>
    <description>Recent content in Rcpp on GGVY</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016 George G. Vega Yon</copyright>
    <lastBuildDate>Thu, 25 Jul 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/rcpp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Working with sparse matrices in C&#43;&#43; (part 2)</title>
      <link>/post/working-with-sparse-matrices-in-cpp-part2/</link>
      <pubDate>Thu, 25 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/working-with-sparse-matrices-in-cpp-part2/</guid>
      <description>Last time I talked about this, iterators in armadillo were fast only in the constext of colum-major access, since data is stored like that. Today, the developers of armadillo, Dr Conrad Sanderson and Dr Ryan Curtin, have work furiously on adding new features to the header-only library, which has lead me to update the results of a benchmark I wrote on 2018:
#include &amp;lt;RcppArmadillo.h&amp;gt; // [[Rcpp::depends(RcppArmadillo)]] using namespace Rcpp; // Column-major method iterator (default) // [[Rcpp::export]] arma::vec sp_iterate(arma::sp_mat x) { arma::vec ans(x.</description>
    </item>
    
    <item>
      <title>Working with sparse matrices in C&#43;&#43;</title>
      <link>/post/working-with-sparse-matrices-in-cpp/</link>
      <pubDate>Tue, 16 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/working-with-sparse-matrices-in-cpp/</guid>
      <description>Working with sparse matrices is a big part of my day. Social networks are inherently sparse, so sparse matrices are the best buds you can get when representing large networks as adjacency matrices.1 As so, I usually find myself trying to take advantage of their structure as, contrasting dense matrices, we donâ€™t need to write nested for(i...) for (j...) loops to work with them, instead, sometimes all what we want is just to extract/work with its non-zero elements.</description>
    </item>
    
    <item>
      <title>Profiling Rcpp</title>
      <link>/post/profiling-rcpp/</link>
      <pubDate>Tue, 14 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/profiling-rcpp/</guid>
      <description> Install libuwind
$ wget http://download.savannah.nongnu.org/releases/libunwind/libunwind-1.2.tar.gz &amp;amp;&amp;amp; \ tar -xf libunwind-1.2.tar.gz &amp;amp;&amp;amp; cd libunwind-1.2; \ ./configure; sudo make; sudo make install Install google-perftools
$ git clone https://github.com/gperftools/gperftools $   </description>
    </item>
    
    <item>
      <title>Setting up optional OpenMP support with RcppArmadillo</title>
      <link>/post/setting-up-optional-openmp-support-with-rcpparmadillo/</link>
      <pubDate>Tue, 29 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/setting-up-optional-openmp-support-with-rcpparmadillo/</guid>
      <description>Setting up an R package that supports OpenMP can be a bit awkward. While systems like Ubuntu with g++ have straight forward support for -fopenmp flags, the same may not be true un MacOS&amp;rsquo;s clang, since the latter is not shipped with it.
In order to solve this, it is necesary to have different src/Makevars file depending on whether the compiler supports OpenMP or not. This can be solved using a configure file, more over, autoconf.</description>
    </item>
    
  </channel>
</rss>